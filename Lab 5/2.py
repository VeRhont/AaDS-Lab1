def matrixChainOrder(p):
    n = len(p) - 1  # количество матриц в последовательности
    dp = [[0 for _ in range(n)] for _ in range(n)]  # создаем матрицу dp размером n x n

    # заполняем матрицу dp по алгоритму
    for length in range(2, n + 1):  # для каждой длины подпоследовательности от 2 до n
        for i in range(1, n - length + 2):  # для каждого начального индекса i от 1 до n - l + 1
            j = i + length - 1
            dp[i - 1][j - 1] = float('inf')  # инициализируем минимальное количество операций как бесконечность
            for k in range(i, j):  # перебираем все возможные разбиения подпоследовательности на две части
                q = dp[i - 1][k - 1] + dp[k][j - 1] + p[i - 1] * p[k] * p[j]
                dp[i - 1][j - 1] = min(dp[i - 1][j - 1], q)  # выбираем разбиение с минимальным количеством операций

    return dp[0][n - 1]  # возвращаем минимальное количество скалярных операций для умножения всех матриц


# Пример использования
matrices = [10, 20, 15]  # размеры матриц в последовательности
result = matrixChainOrder(matrices)
print("Минимальное количество скалярных операций:", result)


# def main():
#     A = (5, 10)
#     B = (10, 20)
#     C = (20, 35)
#
#
# if __name__ == '__main__':
#     main()